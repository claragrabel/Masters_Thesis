---
title: "gProfiler enrichment on Populations"
author: "H. Christoph Liedtke"
date: "2024-05-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

In this document, we will analyse DESeq2 results via a functional enrichment analysis

## Prep environment

Set working directory and load libraries

```{r}
#setwd("~/Desktop/rnaseq/")
setwd("~/Documents/students_MSc/clara/rnaseq/")

library(DESeq2)
library(tidyverse)
library(gprofiler2)
```


## Load data

Let's load the results files we need.

```{r}
# the list of DEG results from the previous exercises
res<-readRDS("./results/deseq2_regions_results.rds")

# the annotations
xtrop<-read_csv("./xtr109/diamondblast109.csv")
```

## Prepare gene sets and background

Ideally, the annotations of your genes should come from experimental evidence from your organism. If you work with mice, _Drosophila_ or humans for example, many functional enrichment analysis tools will be very easy to implement because they will automatically connect your lists of genes to annotations, background lists etc. This is unlikely going to exist if you work with non-model systems. We are therefore dependent on making our own annotations and lists.  

For our annotations, we are using BLAST results from querying our genes against the proteome of _Xenopus tropicalis_. This is a well studied frog species. It is still only distantly related to our focal species, but this is the best we can do. As we saw in the previous exercise, this results in many genes not having any annotations. These will be excluded unfortunately.

### Make gene sets

pull out DEGs and convert to xenopus IDs

```{r}
pull_genes<-function(x, alpha=0.05, lfc=0, signed="both", feature="xenp_gene_symbol") {
  
  # filter by adjusted p
  x<-x %>%
    filter(padj<alpha)
  
  if(signed=="up"){
    x<-x %>%
      filter(log2FoldChange>lfc) %>%
      pull(feature)
  }
  
  if(signed=="down"){
    x<-x %>%
      filter(log2FoldChange<(lfc*-1)) %>%
      pull(feature) 
  }
  
  if(signed=="both"){
    x<-x %>%
      filter(abs(log2FoldChange)>lfc) %>%
      pull(feature) 
  }
  
  ## deal with multiple gene annotations for the same gene (different transcripts)
  
  x<-strsplit(x, ";") %>% unlist() %>% unique()
  x<-x[!is.na(x)]
  
  return(x[!is.na(x)])
}

# now extract all

sig_deg<-lapply(res, FUN=function(x) 
  x %>%
  as_tibble(rownames = "gene_id") %>%
  left_join(xtrop) %>%
    pull_genes(feature = "xenp_pep_id", alpha = 0.05, lfc=0, signed = "both")
)
str(sig_deg)
```

### Make background

There is some discussion about what makes a good background. Ideally, it should be the complete list of genes that *could* be differentially expressed. But what is this?


We will use the full set of genes that were returned by `DESeq2`. This set should have filtered out genes that have low counts (i.e. unlikely to be expressed across any of our tissues/conditions).

We can use the same function from earlier to convert our list of _Pelobates_ IDs to _Xenopus_ peptide IDs.

```{r}
# function to pull out xtr background IDs
extract_xtr<-function(x) {
  return(
      xtrop %>%
        filter(gene_id %in% x) %>%
        pull(xenp_pep_id) %>%
        str_split(pattern=";") %>%
        unlist() %>%
        na.omit() %>%
        unique()
  )
}

xtr_bg<-lapply(res, FUN= function(x) extract_xtr(rownames(x)))
str(xtr_bg)

# lets unify the background to use the same across all populations
xtr_bg_all<-xtr_bg %>%
  unlist() %>%
  unique()

```

## Functional Enrichment Analysis

We are now ready to go! There are a number of software and R packages that let you perform functional enrichment analysis. Here, we will use [g:Profiler])(https://biit.cs.ut.ee/gprofiler/), because it plays particularly well with R and with Ensembl gene/peptide annotations.  

```{r}
# set base url:
set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e109_eg56_p17/")

# run the analysis
res_ora<-gost(multi_query = FALSE, # returns separate results tables for multiquery
              custom_bg = xtr_bg_all, # our background
              query=sig_deg, # our list of gene sets
              organism="xtropicalis", # the organism our annotations belong to
              exclude_iea = FALSE, # include GO terms that were electronically assigned
              correction_method = "gSCS", # the recommended multiple testing correction.
              sources=c("GO:BP","GO:CC","GO:MF", "KEGG","REAC"), # the functional sets we are interested in 
              evcodes=FALSE, ## evcodes TRUE needed for downstream analysis like enrichment maps in Cytoscape, but this takes longer.
              significant= FALSE) # return all terms, not just the significant ones


# the results are stored as a "results" dataframe 
head(res_ora$result)
```



We can use a p_value cutoff of 0.05 to see how many terms have been functionally enriched in each term.

```{r}
res_ora$result %>%
  filter(p_value<0.05) %>%
  group_by(query) %>%
  dplyr::count(query, sort=TRUE)
```


## GOST plot

```{r fig.height=12, fig.fullwidth=TRUE}
gostplot(res_ora)
```


## Dotplot

custom dot plot using the gprofiler results tables and ggplot.

```{r fig.height=12, fig.fullwidth=TRUE}
res_ora$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>%
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  #scale_color_scico(palette = "batlow", direction = -1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```

