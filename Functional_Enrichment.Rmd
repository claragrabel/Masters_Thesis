---
title: "Functional Enrichment"
author: "clagrabel"
date: "2024-03-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Functional Enrichment

We will study whether genes belonging to specific annotated gene sets, such as Gene Ontology (GO) terms, are enriched in the set of genes of interest, in this case the list of differentially expressed genes (DEGs). This analysis is commonly referred to as Over-Representation Analysis (ORA).

To conduct such an analysis, we need:

* A set of genes obtained from experimental data that are biologically relevant for our research, in this case the list of DEGs. These genes must be annotated, meaning we need information about which known biological functions they are associated to. For this, we will make use of an annotation file generated through BLASTing _Pelobates cultripes_ transcripts against the Ensembl _Xenopus tropicalis_ proteome using diamond (v2.1.8).

* A 'background' set of genes, which includes all genes that could potentially have been differentially expressed. This background set serves as the reference against which the enrichment of specific gene sets is assessed.

* A curated database containing biologically relevant categories, such as GO terms or gene pathways, along with the genes associated with each category. 


## Loading the annotation

This annotation file contains all _P. cultripes_ transcripts by rows. As columns, we can find:
* The gene IDs for _P. cultripes_, foll.owed by the transcripts IDs and the peptides IDs (gene_id, transcript_id, peptide_id)
* The IDs  and descriptions of _X. tropicalis_ annotated proteome resulting from both nucleotide and peptide blasting against _P. cultripes_ transcripts (xenx_pep_id, xenx_gene_symbol, xenx_description, xenp_pep_id, xenp_gene_symbol, xenp_description).


```{r}
# The list of DEG results was already loaded

# The annotation file
xtrop<-read_csv("diamondblast109.csv")

```


-----------------------


# DOUBT

Is it broader from the nucleotide blast? therefore I can get more annotated genes, but peptides are more precise.

# DOUBT

diamondblast109.csv

Is gprofiler already taking into account the multiple annotations separated by ;??
No? it shows that many of the fields which had multiple values (more than 1 annotation) failed. It's supposed to be 329 genes who experimented this error.
$failed
  [1] "ENSXETP00000109036;ENSXETP00000059920"                                                         
  [2] "ENSXETP00000073397;ENSXETP00000066469;ENSXETP00000089559"                                      
  [3] "ENSXETP00000033990;ENSXETP00000061006"                                                         
  [4] "ENSXETP00000064368;ENSXETP00000094636"                                                         
  [5] "ENSXETP00000097080;ENSXETP00000108729"                                                         
  [6] "ENSXETP00000097182;ENSXETP00000072551"                                                         
  [7] "ENSXETP00000073307;ENSXETP00000003902"                                                         
  [8] "ENSXETP00000021904;ENSXETP00000073742"                                                         
  [9] "ENSXETP00000109349;ENSXETP00000113582"                                                         
 [10] "ENSXETP00000110359;ENSXETP00000064219;ENSXETP00000055424" 

Possible ways of using this annotation file?
(for many genes there is only the xenx_pep_id and xenp_pep_id, for some there is the description too)
* Consider each annotation separately (selecting only 1 annotation resulting from a blast, what I am doing here).
* Combine annotations somehow, aggregation? using some criteria
  + choosing the annotation with the higher score


-----------------


However, this annotation file contains multiple annotations per gene. This means, in the columns corresponding to the results of BLASTing the genes, the fields (ID field or description field), we can find more than one element that is associated to one only gene.

g:Profiler is unable to process this entries, therefore we have to choose only one annotation for each gene.
I will only choose the first element of each field.
This code splits each field by ;, selects the first element ([,1]), and replaces the original field value with this element.

```{r}
xtrop_processed<- xtrop %>%
  mutate(across(everything(), ~str_split(.x, ";", simplify = TRUE)[, 1]))

```



```{r eval=FALSE, include=FALSE}
# The annotation file used in the workshop had the same issue.

old_xtrop<-read_csv("PCU23_annotations_xtr105_genes.csv")
```


Since we will be repeateadly extracting the IDs from this annotation file for the multiple comparisons, we will make a function that extracts matching _X. tropicalis_ IDs.

We will first focus on the protein IDs resulting from BLASTP.

```{r}
extract_xtr<-function(x) {
  return(
      xtrop %>%
        filter(gene_id %in% x) %>% #Filtering data frame (xtrop) to select rows where the gene_id column matches any of the IDs provided in the input list (x).
        pull(xenp_pep_id) %>% #Extracts the values from the xenp_pep_id column of the filtered data frame.
        unique()
  )
}

# Applying this function to a list of Pelobates IDs
xtr_deg<-lapply(all_degs_test, FUN=extract_xtr)



str(all_degs_test)
str(xtr_deg)
```

Very few genes were not found in the annotation. 


```{r}
extract_xtr_proc<-function(x) {
  return(
      xtrop_processed %>%
        filter(gene_id %in% x) %>% #Filtering data frame (xtrop) to select rows where the gene_id column matches any of the IDs provided in the input list (x).
        pull(xenp_pep_id) %>% #Extracts the values from the xenp_pep_id column of the filtered data frame.
        unique()
  )
}

# Applying this function to a list of Pelobates IDs
xtr_deg_proc<-lapply(all_degs_test, FUN=extract_xtr_proc)

xtr_deg_res_proc<-lapply(all_degs, FUN=extract_xtr_proc)

str(all_degs_test)
str(xtr_deg_proc)

str(xtr_deg_res_proc)
```


# Make background

As the background, we will use the all the genes that could be annotated in the Pelobates genome. 
This way, we ensure that the background includes the genes that are potentially relevant to our study system while capturing the variability in gene expression across different conditions.

Since _X. tropicalis_ is a different species, using all genes annotated in the Xenopus proteome could introduce genes that are not present in Pelobates, or may not accurately represent the genes that are relevant to the specific conditions of this study (regions and water level).


```{r eval=FALSE, include=FALSE}

rownames_bg<-unique(c(rownames(test_waterLevel), rownames(test_region), rownames(test_interaction), rownames(test_lS_hS), rownames(test_lC_hC), rownames(test_hS_hC), rownames(test_lS_lC)))

head(rownames_xtr_bg)
length(rownames_xtr_bg)
class(rownames_xtr_bg)

rownames_bg_res<-unique(c(rownames(res_waterLevel), rownames(res_region), rownames(res_interaction), rownames(res_lS_hS), rownames(res_lC_hC), rownames(res_hS_hC), rownames(res_lS_lC)))

xtr_background<-lapply(rownames_bg, FUN=extract_xtr)

xtr_background_res<-lapply(rownames_bg, FUN=extract_xtr_proc)


head(xtr_background)
class(xtr_background)

all_degs_test$test_waterLevel
rownames(all_degs_test)
rownames(xtr_background)

str(all_degs_test)
str(xtr_background)

# xtr_background
# xtr_bg_vector<-unlist(xtr_background)
# xtr_bg_vector
# class(as.vector(xtr_background))
```

```{r}
all_xtr_bg<-unique(c(extract_xtr(rownames(test$test_lC_hC)), extract_xtr(rownames(test$test_lS_hS)), extract_xtr(rownames(test$test_lS_lC)), extract_xtr(rownames(test$test_hS_hC)), extract_xtr(rownames(test$test_waterLevel)), extract_xtr(rownames(test$test_region)), extract_xtr(rownames(test$test_interaction))))

str(all_xtr_bg)
all_xtr_bg[1:20]
```


```{r}
all_xtr_bg_proc<-unique(c(extract_xtr_proc(rownames(test$test_lC_hC)), extract_xtr_proc(rownames(test$test_lS_hS)), extract_xtr_proc(rownames(test$test_lS_lC)), extract_xtr_proc(rownames(test$test_hS_hC)), extract_xtr_proc(rownames(test$test_waterLevel)), extract_xtr_proc(rownames(test$test_region)), extract_xtr_proc(rownames(test$test_interaction))))

str(all_xtr_bg_proc)
all_xtr_bg_proc[1:20]


res_bg_proc<-unique(c(extract_xtr_proc(rownames(res$lC_hC)), extract_xtr_proc(rownames(res$lS_hS)), extract_xtr_proc(rownames(res$lS_lC)), extract_xtr_proc(rownames(res$hS_hC)), extract_xtr_proc(rownames(res$waterLevel)), extract_xtr_proc(rownames(res$region)), extract_xtr_proc(rownames(res$interaction))))
```


## g:Profiler

We will use g:Profiler tool, which is a web-based tool for functional enrichment analysis of gene lists. 

The associated R package for g:Profiler is gprofiler2, which is an API (Application Programming Interface). This API serves as a bridge that allows performing the actual analysis within the g:Profiler server, by using the R environment in RStudio.

g:Profiler is continuously being updated to match the updates in the associated Ensembl and Ensembl Genomes Data Bases. Because of this, it is important to specify which version of g:Profiler, and therefore Ensembl version, we would like to use. 
We will do this by looking at the archives on the g:Profiler homepage and setting the base url for the desired version.

Our annotations resulted from BLASTing _P. cultripes_ transcriptome against the 109 Ensembl release of the _X. tropicalis_ proteome, therefore we will use Ensembl 109, Ensembl Genomes 56 (database built on 2023-03-29).


```{r}

# Install and load the gprofiler2 package. This package provides functions to access the gprofiler API directly from R. 

# install.packages("gprofiler2")
library(gprofiler2)

# Setting the base url

set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e109_eg56_p17")


# Run the analysis
test_ora<-gost(multi_query = FALSE, # returns separate results tables for multiquery
              custom_bg = all_xtr_bg, # our background
              query=xtr_deg, # our list of gene sets
              organism="xtropicalis", # the organism our annotations belong to
              exclude_iea = FALSE, # include GO terms that were electronically assigned
              correction_method = "gSCS", # the recommended multiple testing correction.
              sources=c("GO:BP","GO:CC","GO:MF", "KEGG","REAC"), # the functional sets we are interested in 
              evcodes=FALSE, # evcodes TRUE needed for downstream analysis like enrichment maps in Cytoscape, but it takes longer.
              significant= FALSE) # return all terms, not just the significant ones


# The results are stored as a "results" dataframe 
head(test_ora$result)
dim(test_ora$result)
#str(test_ora$meta)

```


```{r}

# Install and load the gprofiler2 package. This package provides functions to access the gprofiler API directly from R. 

# install.packages("gprofiler2")
library(gprofiler2)

# Setting the base url

set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e109_eg56_p17")


# Run the analysis
test_ora_proc<-gost(multi_query = FALSE, # returns separate results tables for multiquery
              custom_bg = all_xtr_bg_proc, # our background
              query=xtr_deg_proc, # our list of gene sets
              organism="xtropicalis", # the organism our annotations belong to
              exclude_iea = FALSE, # include GO terms that were electronically assigned
              correction_method = "gSCS", # the recommended multiple testing correction.
              sources=c("GO:BP","GO:CC","GO:MF", "KEGG","REAC"), # the functional sets we are interested in 
              evcodes=FALSE, # evcodes TRUE needed for downstream analysis like enrichment maps in Cytoscape, but it takes longer.
              significant= FALSE) # return all terms, not just the significant ones

res_ora_proc<-gost(multi_query = FALSE, # returns separate results tables for multiquery
              custom_bg = res_bg_proc, # our background
              query=xtr_deg_res_proc, # our list of gene sets
              organism="xtropicalis", # the organism our annotations belong to
              exclude_iea = FALSE, # include GO terms that were electronically assigned
              correction_method = "gSCS", # the recommended multiple testing correction.
              sources=c("GO:BP","GO:CC","GO:MF", "KEGG","REAC"), # the functional sets we are interested in 
              evcodes=FALSE, # evcodes TRUE needed for downstream analysis like enrichment maps in Cytoscape, but it takes longer.
              significant= FALSE) # return all terms, not just the significant ones



# The results are stored as a "results" dataframe 
head(test_ora$result)
dim(test_ora$result)
#str(test_ora_proc$meta)
length(test_ora_proc$meta$genes_metadata$failed)
```

0 supposedly from the metadata failed, compared to 329 before.


Let's look at the enrichment results in detail

```{r}
colnames(test_ora$result)
```

* **query**: This column represents the gene set or query submitted to g:Profiler for enrichment analysis. Each row corresponds to a different gene set or query.

* **significant**: This column indicates whether the enrichment analysis identified the term (functional category) as statistically significant. It contains a boolean value (TRUE or FALSE).

* **p_value**: This column contains the adjusted p-values. Each p-value indicates the statistical significance of enrichment of a given term in the gene set.

* **term_size**: This column represents the total number of genes in a specific term (functional category).

* **query_size**: This column represents the total number of genes in the submitted query or gene set.

* **intersection_size**: This column represents the number of genes that are shared between the submitted query and the term being analyzed. That is, how many genes from both term size and query size are overlapping. 

* **term_id**: This column contains the unique identifier (ID) associated with the term (functional category) being analyzed.

* **term_name: This column contains the name or description of the term (functional category) being analyzed.**

* source: This column indicates the data source or database from which the term originates and that we requested (Gene Ontology, KEGG, Reactome).

* precision: This column represents the proportion of the genes shared between the submitted query and the term being analyzed, relative to the total number of genes in the query. It measures the accuracy of the enrichment analysis. A higher precision value indicates that a larger proportion of the genes in the intersection are relevant to the term being analyzed, relative to the total number of genes in the query. In other words, it reflects how well the term represents the genes in the query.

* recall: This column represents the proportion of the genes in the intersection, the same as the precision column, but relative to the total number of genes in the term. It reflects how well the term represents the genes in the dataset or background.

* effective_domain_size: This column represents the effective domain size used in the enrichment analysis. It is a statistical parameter used to calculate the p-value.

* source_order: This column represents the order or rank of the source (data database) based on its importance or relevance in the enrichment analysis.

* parents: This column contains information about the parent terms or higher-level categories to which the analyzed term belongs. It may provide additional hierarchical context for the analyzed terms.


## Analyzing the results

We can use a p-value cutoff of 0.05 to see how many terms have been functionally enriched in each gene set.

```{r}
test_ora$result %>%
  filter(p_value<0.05) %>%
  group_by(query) %>%
  dplyr::count(query, sort=TRUE)

```

```{r}
test_ora_proc$result %>%
  filter(p_value<0.05) %>%
  group_by(query) %>%
  dplyr::count(query, sort=TRUE)


res_ora_proc$result %>%
  filter(p_value<0.05) %>%
  group_by(query) %>%
  dplyr::count(query, sort=TRUE)
```
The difference in the number of enriched terms is only 6 more or less, except for the lS_lC that is reduced by 14.


## visualization

```{r}
gostplot(test_ora)
```


```{r fig.height=17, fig.width=12}
test_ora$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>% # this is actually the precision column
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  scale_color_scico(palette = "batlow", direction = -1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```

```{r fig.height=20, fig.width=12}
test_ora_proc$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>%
  # filter(GeneRatio>0.10) %>% I could do this to reduce the number of enriched terms somehow
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  scale_color_scico(palette = "batlow", direction = -1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```

```{r fig.height=20, fig.width=12}
test_ora_proc$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>%
  filter(GeneRatio>0.10) %>% 
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  scale_color_scico(palette = "batlow", direction = -1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```


```{r fig.height=20, fig.width=12}
res_ora_proc$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>%
  # filter(GeneRatio>0.10) %>% I could do this to reduce the number of enriched terms somehow
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  scale_color_scico(palette = "batlow", direction = -1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```




# DOUBT

Why are there some terms that are not shared between water level and the two regions comparisons if they're all about metabolism?


# Volcano 


# Functional enrichment with Llano Population

```{r}
res_xtr_bg_proc<-unique(c(extract_xtr_proc(rownames(res$lC_hC)), extract_xtr_proc(rownames(res$lS_hS)), extract_xtr_proc(rownames(res$lS_lC)), extract_xtr_proc(rownames(res$hS_hC)), extract_xtr_proc(rownames(res$waterLevel)), extract_xtr_proc(rownames(res$region)), extract_xtr_proc(rownames(res$interaction))))

str(all_xtr_bg_proc)
all_xtr_bg_proc[1:20]
```
```

