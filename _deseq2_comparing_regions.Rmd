---
title: "_deseq2_comparing_regions"
author: "H. Christoph Liedtke"
date: "2024-05-21"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

In this document, we will analyse RNAseq data (counts at gene level from salmon) using DESeq2. The data comes from 6 populations (of 2 geographic regions) and each population was subjected to benign conditions (constant high water level) and stressful conditions (low water level).

## Prep environment

Set working directory and load libraries

```{r}
#setwd("~/Desktop/rnaseq/")

pacman::p_load(DESeq2, tidyverse, fdrtool, UpSetR, GGally)
```

## Import read counts

Import counts prepared with tximport and clean

```{r}
txi<-readRDS("./salmon_gene_counts.rds")

```


Remove non-coding regions and baits

```{r}

# remove mtDNA, non-coding and nr baits

# make a list of genes we want to keep
whitelist<-txi$counts %>%
  as_tibble(rownames = "gene_id") %>%
  filter(!str_detect(gene_id, pattern = "mt|nr|nc")) %>%
  pull(gene_id)

length(whitelist);head(whitelist) # we are keeping 32531 genes

# filter txi tables
txi$abundance<-txi$abundance[whitelist,]
txi$counts<-txi$counts[whitelist,]
txi$length<-txi$length[whitelist,]
```


## Load design matrix

Load the "column data" for the dds object. 

```{r}

### load design matrix
des.mat<-read_csv("./design_matrix.csv")

# re order factor levels
des.mat <- des.mat %>%
  mutate(population=factor(population, levels=c("Bui","Can","Tur","Esp","Jab","Lla"))) %>% # re-order factors for easy plotting later
  mutate(pop_n = factor(rep(rep(1:3,each=8),2))) %>% # make new, non-nested pop variable !!! BECAREFUL WITH THE ORDER OF VARIABLES
  mutate_if(is.character, as.factor) # convert characters to factor


# filter samples that had substantially lower library size (Jab) and a potential outlier (Bui)
des.mat<-des.mat %>%
  filter(!sample_id %in% c("Bui4H14_nonrrna","Jab5H6_nonrrna")) # could also remove: "Tur2H6_nonrrna","Bui1L9_nonrrna"

# filter txi tables
txi$abundance<-txi$abundance[,as.character(des.mat$sample_id)]
txi$counts<-txi$counts[,as.character(des.mat$sample_id)]
txi$length<-txi$length[,as.character(des.mat$sample_id)]

## get column order of counts matrix and re-order des.mat to match
col_order<-match(colnames(txi$counts),des.mat$sample_id)
des.mat<-des.mat[col_order,]
des.mat$sample_id==colnames(txi$counts)

des.mat

```

## Make DESeq objects


Make deseq object. Our primary object is to test what the effect of dropping the water level on tadpoles results is on tadpoles from the south or central populations. We therefore want to contrast high vs. low water for each of the regions and so we have to include a region:treatment interaction effect. However, we are expecting region alone to be an important factor affecting gene expression (almost like a batch effect) and we also want to correct for potential minor differences of having sampled different populations within each regions. See a similar setup here: https://support.bioconductor.org/p/87324/. 
  
Here, the formula is constructed in such a way that populations are treated as replicates per region. In order for this to work, we have to re-code the populations as 1 to 3 within each region (see chunk above). Otherwise, each population/replicate is unique to each region and will throw back an error.
  
We drop the intercept (first term in the formula is zero), because this allows us to more easily compare contrasts. If not, the base level expression would be that of the intercept, which is more difficult to intepret for such a complex model design. Read more here: https://www.biostars.org/p/395926/ 

  
```{r}
dds<-DESeqDataSetFromTximport(txi,
                              colData = des.mat,
                              design = ~ 0+region + region:pop_n + region:treatment)

# make sure metadata is in matching order
des.mat$sample_id==colnames(assay(dds))

```

## Pre filtering

This is an ambiguous step. It may be worth playing around with how this affects the final outcome.

```{r}
rowSums(counts(dds)) %>%
          enframe() %>%
  ggplot(aes(x=value)) +
  geom_histogram() +
  scale_x_log10()

# lets apply 2 different filters

dds1<-dds[rowSums(counts(dds) >= 1) >= 12,] # genes that have at least 1 count for 12 samples (e.g. one per treatment per population)
dim(dds1) # we are left with ~18k genes 

dds2<-dds[rowSums(counts(dds) >= 50) >= 12,] # genes that have at least 10 counts for 12 samples (e.g. one per treatment per population)
dim(dds2) # we are left with ~14k genes 
```


## Data exploration

Its always a good idea to plot a PCA of the counts data.  
 
Although for the actual DE expression we use raw count data, for visualization or clustering, it makes more sense to use some sort of transformed count. DESeq authors argue that variance stabilized transformation (VST) or regularized logarithm (rlog) have certain advantages. VST is faster, i.e. good for large datasets, rlog is more often used for small datasets. lets do vst

```{r}
# vst transformation
vst_dds<-vst(dds, blind = T) # no filtering
vst_dds1<-vst(dds1, blind = T) # mild filtering
vst_dds2<-vst(dds2, blind = T) # hard filtering

# perform PCA on TRANSPOSED scaled, centered data
vst_pca<- prcomp(t(assay(vst_dds)),  center = T)
vst_pca1<- prcomp(t(assay(vst_dds1)), center = T)
vst_pca2<- prcomp(t(assay(vst_dds2)), center = T)

```

To plot multiple axes at once, I am going to use paired plots. The densities on the diagonal are also useful for seeing which PC does the best job at separating out treatments. 

### PCA emphasizing regions
```{r}
vst_pca$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4","PC5","PC6"),  aes(color=region, shape=treatment)) +
  ggtitle("VST PCA (no filtering)")


vst_pca1$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4","PC5","PC6"),  aes(color=region, shape=treatment)) +
  ggtitle("VST PCA (mild liftering)")

vst_pca2$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4","PC5","PC6"),  aes(color=region, shape=treatment)) +
  ggtitle("VST PCA (hard liftering)")

#vst_pca2$x[,colnames(vst_pca$x)=="PC5"]<(-40)

# using canned function from DESeq2
#plotPCA(vst_dds, intgroup=c("region"), ntop=Inf) +
#  coord_fixed()

```

Here we can quite clearly see that the strongest effect is that of the region. PC1 separates them out quite neatly.

Filtering doesn't have a noticeable effect.

### PCA emphasizing treatment
```{r}
vst_pca1$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4","PC5","PC6"),  aes(color=treatment, shape=region)) +
  ggtitle("VST PCA")
```

Plotting the same PCA, but colouring treatments rather than regions, shows that we have to go down to PC3 to start getting treatment separations. PC1 vs PC3 may give us the best separation of both region and treatment.

We can plot specific axes again to highlight some of this more clearly.

```{r}

# calculate hulls
pca_hull <- 
  vst_pca1$x %>% 
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>%
  group_by(population, treatment) %>% 
  dplyr::slice(chull(PC1, PC3))

# plot PCA and facet into different populations
vst_pca1$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggplot(aes(x=PC1, y=PC3, color=population, shape=treatment)) +
  geom_hline(yintercept = 0, linewidth=0.1) +
  geom_vline(xintercept = 0, linewidth=0.1) +
  geom_point(size=3) +
  geom_polygon(data = pca_hull,
               aes(fill = population,
                   colour = population,
                   linetype=treatment),
               alpha = 0.1,
               show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(label=sample_id),size=2) +
  scale_color_manual(values=c("Bui"="#900C3F", "Can"="#FF5733", "Tur"="#FFC300",
                              Esp="#0FBA3D", "Jab"="#0FBA93", "Lla"="#0F8CBA"))+
  scale_fill_manual(values=c("Bui"="#900C3F", "Can"="#FF5733", "Tur"="#FFC300",
                              Esp="#0FBA3D", "Jab"="#0FBA93", "Lla"="#0F8CBA"))+
  facet_wrap(~population) +
  theme_minimal()

```


we can just about see that the warm colours (central populations) are found on the left side of the plotting area and the green colours (southern) on the right side. So PC1 is splitting regions quite well. the Y axis (PC3) on the other hand is fairly consistently splitting the triangles from the squares (except for maybe in Tur). So we are getting a consistent treatment signal too.


## Differential gene expression

we can now run the DESeq pipeline, which will automatically run a number of steps including controlling for different library sizes etc, and finally also fitting the generalized linear model. 

```{r}
dds <- DESeq(dds)
dds1 <- DESeq(dds1)
dds2 <- DESeq(dds2)
```


## Run Wald's test comparing high vs low treatments for each of the two regions

```{r}
resultsNames(dds1) # there are many coefficients (effects), due to the population replicates, but we are not really interested in all of these

# compares Low vs High (high is the reference level for treatment) in the central region
res_treat_central<-results(dds1, name="regioncentral.treatmentL")  
summary(res_treat_central, alpha=0.05)

# compares Low vs High (high is the reference level for treatment) in the central region
res_treat_south<-results(dds1, name="regionsouth.treatmentL")  
summary(res_treat_south, alpha=0.05)

# lets combine them into a list

res_dds<-list("central"=res_treat_central,
              "south"=res_treat_south)

```

Relatively low numbers of DEGs. We should diagnose our models

## examine results

```{r}
# lets look at the P-value distributions
par(mfrow=c(2,1))
for(i in 1:length(res_dds)){
  hist(res_dds[[i]]$pvalue, breaks=40, col="grey", main=names(res_dds)[i])
}
par(mfrow=c(1,1))
```

They look OK


```{r}
# plot
res_dds %>%
  lapply(as_tibble,rownames = "gene_id") %>%
  bind_rows(.id="population") %>%
  drop_na(padj) %>% # drop all genes with NAs
  filter(padj<0.1) %>%
  mutate(updown=ifelse(log2FoldChange>0, "up", "down")) %>%
  group_by(population, updown) %>%
  summarise(n=n()) %>%
  mutate(n=ifelse(updown=="down", n*-1, n)) %>%
  ggplot(aes(x=population, y=n, fill=updown)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(legend.position = "none")
```

## Local dispersion fits

in general, p values should be evenly distributed, with an inflation of p=0. Common "bad" distributions include "U-shaped" distributions or "hill shaped" distributions. The present distribution is not bad, but we can see if it would be better using a local fit instead of a parametric fit for the dispersion.

```{r}
# Whether a gene is called significant depends not only on its LFC but also on its within-group variability, which DESeq2 quantifies as the dispersion.
## we can inspect the dispersion of a (default) parametric fit vs a local fit
disp.par <- estimateDispersions(dds1, fitType = "parametric")
disp.loc <- estimateDispersions(dds1, fitType = "local")
par(mfrow=c(2,1))
plotDispEsts(disp.par, main= "dispEst: parametric")
plotDispEsts(disp.loc, main= "dispEst: local")
par(mfrow=c(1,1))


### calculate median of absolute residuals
median(abs(log(mcols(disp.par)$dispGeneEst) - log(mcols(disp.par)$dispFit)))
median(abs(log(mcols(disp.loc)$dispGeneEst) - log(mcols(disp.loc)$dispFit)))
## it seems like the local fit is a little better (lower mean absolute residuals, suggesting that that the distance of the residuals to the best fit line is lower)
### we can calculate the new results using local fit type

dds.loc<-DESeq(dds1, fitType = "local")
resultsNames(dds.loc)

# compares Low vs High (high is the reference level for treatment) in the central region
res_loc_treat_central<-results(dds.loc, name="regioncentral.treatmentL")  
summary(res_loc_treat_central, alpha=0.05)

# compares Low vs High (high is the reference level for treatment) in the central region
res_loc_treat_south<-results(dds.loc, name="regionsouth.treatmentL")  
summary(res_loc_treat_south, alpha=0.05)

# lets combine them into a list

res_dds_loc<-list("central"=res_loc_treat_central,
              "south"=res_loc_treat_south)

par(mfrow=c(2,1))
for(i in 1:length(res_dds_loc)){
  hist(res_dds_loc[[i]]$pvalue, breaks=40, col="grey", main=names(res_dds_loc)[i])
}
par(mfrow=c(1,1))
```

In general, very similar results, though perhaps a slight improvement


```{r}
# plot
res_dds_loc %>%
  lapply(as_tibble,rownames = "gene_id") %>%
  bind_rows(.id="population") %>%
  drop_na(padj) %>% # drop all genes with NAs
  filter(padj<0.1) %>%
  mutate(updown=ifelse(log2FoldChange>0, "up", "down")) %>%
  group_by(population, updown) %>%
  summarise(n=n()) %>%
  mutate(n=ifelse(updown=="down", n*-1, n)) %>%
  ggplot(aes(x=population, y=n, fill=updown)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(legend.position = "none")
```

## FDR based on empirical null-model

From the pvalue distributions, we can say that perhaps our data is not fitting the default negative binomial Wald test assumptions. Under this test, the p-value distribution is expected to be flat with an enrichment in low p-values. As we don't recover this distribution, we have to conclude that the default DESeq analysis is overestimating the variance in our data.
  
To alleviate this, we have to instead estimate our own null distribution which we can do with the fdrtool package. You can read more about this here: https://seqqc.wordpress.com/2016/01/27/too-few-or-none-differential-expressed-genes-a-way-to-fix-the-null-hypothesis-in-deseq2/

```{r}
# first we have to filter out all genes with NA p-values (fdrtool doesnt like those) and then run fdrtools

res_fdr_dds<-res_dds
res_fdrtools<-list()

for(i in 1:length(res_fdr_dds)){
  
  # 1. remove genes that have been filtered out by DESeq2's independent filtering
  res_fdr_dds[[i]]<-res_fdr_dds[[i]][ !is.na(res_fdr_dds[[i]]$padj), ]
  # 2. remove genes that have been identified by DESeq2 as outliers
  res_fdr_dds[[i]]<-res_fdr_dds[[i]][ !is.na(res_fdr_dds[[i]]$pvalue), ]
  # 3. use z-scores as input to FDRtool to re-estimate the p-value
  res_fdrtools[[i]]<-fdrtool(res_fdr_dds[[i]]$stat, statistic= "normal", plot = F)
  
  # 4.  overwrite old with new fdr values
  res_fdr_dds[[i]]$padj  <- p.adjust(res_fdrtools[[i]]$pval, method = "BH")
}
```

Lets look at these new p values

```{r}
# New diagnostic plots 
par(mfrow=c(2,1))
for(i in 1:length(res_fdrtools)){
  hist(res_fdrtools[[i]]$pval, breaks=40, col="grey", main=names(res_dds)[i])
}
par(mfrow=c(1,1))
```

These look a little better, though notice the more even dispersion of pvalues (i.e. less relative enrichment of low p values)


```{r}
## lets see how many DEGs there are now
lapply(res_fdr_dds, summary, alpha=0.05)
```

We have essentially lost all DEGs for south, and most of north. Seems very strange


## Compare overlap

Rather than just the numbers of genes, we also want to see how many shared sets of genes the different populations have in their sets of DEGs.

```{r}
# make function to extract lists of DEGs per population
extract_degs<-function(x) {
  return(
    x %>%
      as_tibble(rownames = "gene") %>%
      filter(padj<0.05) %>%
      pull(gene)
  )
}

#  extract all
sig_deg<-lapply(res_dds, FUN=extract_degs)
names(sig_deg)
str(sig_deg)

# Plot Upset

upset(fromList(sig_deg),
      nsets = length(sig_deg),
      keep.order = T,
      nintersects = 100,
      number.angles = 0, point.size = 3, line.size = 1,
      sets.x.label = "Number of DEGs",
      set_size.show = TRUE,
      set_size.scale_max = max(sapply(sig_deg, length))+50, # needed only to expand the axis a bit
      text.scale = c(1.2, 1.2, 1.2, 1.2, 1.5, 1.5),
      sets.bar.color = c("skyblue","chartreuse3"),
      order.by=c("degree","freq"))

```

Most DEGs are unique to regions, but we get some genes that are overlapping.  

We can also plot this as Venn diagrams, seeing as there are only two sets

```{r}
library(ggVennDiagram)
library(scico)

sig_deg %>%
  ggVennDiagram(edge_size = 0) +
  scale_fill_scico(palette = "batlow") +
  theme(legend.position="none")

```

## see direction of expression

```{r}
# DEGS only differentially expressed in the central populations
assay(vst_dds1)[sig_deg$central[!sig_deg$central %in% intersect(sig_deg$central,sig_deg$south)],] %>%
  as_tibble(rownames="gene_id") %>%
  pivot_longer(-gene_id, names_to="sample_id", values_to = "vst") %>%
  left_join(des.mat) %>%
  ggplot(aes(x=treatment, y=vst)) +
  stat_summary(aes(group = gene_id, color=gene_id), fun.y = mean, geom = "path") +
  #stat_summary(aes(color = species), fun.data = mean_cl_boot, geom = "errorbar", width = 0.1) +
  stat_summary(aes(color = gene_id), fun.y = mean, geom = "point", size = 2) +
#  geom_point() +
  facet_wrap(~population) +
  scale_y_log10() +
  theme(legend.position = "none")

# DEGS only differentially expressed in the south populations
assay(vst_dds1)[sig_deg$south[!sig_deg$south %in% intersect(sig_deg$central,sig_deg$south)],] %>%
  as_tibble(rownames="gene_id") %>%
  pivot_longer(-gene_id, names_to="sample_id", values_to = "vst") %>%
  left_join(des.mat) %>%
  ggplot(aes(x=treatment, y=vst)) +
  stat_summary(aes(group = gene_id, color=gene_id), fun.y = mean, geom = "path") +
  #stat_summary(aes(color = species), fun.data = mean_cl_boot, geom = "errorbar", width = 0.1) +
  stat_summary(aes(color = gene_id), fun.y = mean, geom = "point", size = 2) +
#  geom_point() +
  facet_wrap(~population) +
  scale_y_log10() +
  theme(legend.position = "none")
```

The differences in slopes between genes for the corresponding sets are not immediately obvious in my opinion

## Export data

Lets export the results with the default null distribution and only light pre-filtering

```{r}
# make a results folder if it does not yet exist
dir.create("results", showWarnings = FALSE)

# save best DESeq2 object
saveRDS(dds1, "./results/deseq2_regions_dds.rds")

# save results object
saveRDS(res_dds,
        "./results/deseq2_regions_results.rds")

saveRDS(res_dds_loc,
        "./results/deseq2_regions_results_local.rds")

```






```{r}
ipak <- function(pkg, repository=c('CRAN', 'Bioconductor', 'github')){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  # new.pkg <- pkg
  if (length(new.pkg)) {
    if(repository=='CRAN') {
      install.packages(new.pkg, dependencies = TRUE)
    }
    if(repository=='Bioconductor') {
      if(strsplit(version[['version.string']], ' ')[[1]][3] > "3.6.0"){
        if (!requireNamespace("BiocManager")){
            install.packages("BiocManager")
        }
            BiocManager::install(new.pkg, dependencies=TRUE, ask=FALSE)
      }
      if(strsplit(version[['version.string']], ' ')[[1]][3] < "3.6.0"){
        stop(message("powsimR depends on packages that are only available in R 3.6.0 and higher."))
      }
    }
    if(repository=='github') {
      devtools::install_github(new.pkg, build_vignettes = FALSE, force = FALSE, dependencies=TRUE)
    }
  }
}

# CRAN PACKAGES
cranpackages <- c("broom", "cobs", "cowplot",
                  "data.table", "doParallel", "dplyr", "DrImpute",
                  "fastICA", "fitdistrplus", "foreach", "future",
                  "gamlss.dist", "ggplot2", "ggpubr", "ggstance", "grDevices",
                  "grid", "Hmisc", "kernlab", "MASS", "magrittr", "MBESS", "Matrix",
                  "matrixStats", "mclust", "methods", "minpack.lm", "moments", "msir",
                  "NBPSeq", "nonnest2", "parallel", "penalized", "plyr", "pscl",
                  "reshape2", "Rmagic", "rsvd", "Rtsne", "scales", "Seurat", "snow", "sctransform",
                  "stats", "tibble", "tidyr", "truncnorm", "VGAM", "ZIM", "zoo")
ipak(cranpackages, repository='CRAN')

# BIOCONDUCTOR
biocpackages <- c("bayNorm", "baySeq", "BiocGenerics", "BiocParallel",
                  "DESeq2", "EBSeq", "edgeR", "IHW", "iCOBRA",
                  "limma", "Linnorm", "MAST", "monocle", "NOISeq", "qvalue", "ROTS", "RUVSeq",
                  "S4Vectors", "scater", "scDD", "scde", "scone", "scran", "SCnorm",
                  "SingleCellExperiment", "SummarizedExperiment", "zinbwave")
ipak(biocpackages, repository='Bioconductor')

# GITHUB
githubpackages <- c('cz-ye/DECENT', 'nghiavtr/BPSC',
                    'mohuangx/SAVER', 'statOmics/zingeR',
                    'Vivianstats/scImpute')
ipak(githubpackages, repository = 'github')
```



```{r}
install.packages('devtools')
library(devtools)
```

