---
title: "Functional_Enrichment"
author: "clagrabel"
date: "2024-06-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Functional Enrichment

We will study whether genes belonging to specific annotated gene sets, such as Gene Ontology (GO) terms, are enriched in the set of genes of interest, in this case the list of differentially expressed genes (DEGs). This analysis is commonly referred to as Over-Representation Analysis (ORA).

To conduct such an analysis, we need:

* A set of genes obtained from experimental data that are biologically relevant for our research, in this case the list of DEGs. These genes must be annotated, meaning we need information about which known biological functions they are associated to. For this, we will make use of an annotation file generated through BLASTing _Pelobates cultripes_ transcripts against the Ensembl _Xenopus tropicalis_ proteome using diamond (v2.1.8).

* A 'background' set of genes, which includes all genes that could potentially have been differentially expressed. This background set serves as the reference against which the enrichment of specific gene sets is assessed.

* A curated database containing biologically relevant categories, such as GO terms or gene pathways, along with the genes associated with each category. 


## Loading necessary libraries

```{r}
library(DESeq2)
library(tidyverse)
library(gprofiler2)
```


## Loading the Data

```{r}

# The list of DEG results
res<-readRDS("./results/deseq2_regions_results_local.rds")
```


## Loading the Annotations


This annotation file contains all _P. cultripes_ transcripts by rows. As columns, we can find:
* The gene IDs for _P. cultripes_, followed by the transcripts IDs and the peptides IDs (gene_id, transcript_id, peptide_id)
* The IDs  and descriptions of _X. tropicalis_ annotated proteome resulting from both nucleotide and peptide blasting against _P. cultripes_ transcripts (xenx_pep_id, xenx_gene_symbol, xenx_description, xenp_pep_id, xenp_gene_symbol, xenp_description).


```{r}
# The annotation file
xtrop<-read.csv("./xtr109/diamondblast109.csv", stringsAsFactors = FALSE)

```


## Creating Gene Sets

However, this annotation file contains multiple annotations per gene. This means, in the columns corresponding to the results of BLASTing the genes, the fields (ID field or description field), we can find more than one element that is associated to one only gene.

g:Profiler is unable to process these entries, therefore we have to process the file so that it can interpret the multiple possible annotations for each gene.

The goal is to split multiple annotations within a single cell, unlist them to handle them individually and ensure uniqueness so that it is understandable for g:Profiler.

We will extract the _X. tropicalis_ gene symbols as input for g:Profiler.

```{r}

pull_genes<-function(x, alpha=0.05, lfc=0, signed="both", feature="xenp_gene_symbol") {
  
  # filter by adjusted p
  x<-x %>%
    filter(padj<alpha)
  
  # 3 modes for filtering based on log fold change, controlled by the signed parameter

  if(signed=="up"){
    x<-x %>%
      filter(log2FoldChange>lfc) %>%
      pull(feature)
  }  # include only genes where the log fold change is greater than a specified threshold (lfc, which defaults to 0)
  
  if(signed=="down"){
    x<-x %>%
      filter(log2FoldChange<(lfc*-1)) %>%
      pull(feature) 
  }  # include only genes where the log fold change is less than the negative of the specified threshold (-lfc)
  
  if(signed=="both"){
    x<-x %>%
      filter(abs(log2FoldChange)>lfc) %>%
      pull(feature) 
  } # include genes where the absolute value of the log fold change is greater than the specified threshold (lfc), includes changes in either direction.
  
  # deal with multiple gene annotations for the same gene (different transcripts)
  
  x<-strsplit(x, ";") %>% unlist() %>% unique()
  # separates different annotations in different rows
  x<-x[!is.na(x)]
  
  return(x[!is.na(x)])
}

# now extract all

sig_deg<-lapply(res, FUN=function(x) 
  x %>%
  as_tibble(rownames = "gene_id") %>%
  left_join(xtrop) %>%
    pull_genes(feature = "xenp_pep_id", alpha = 0.05, lfc=0, signed = "both")
)
```


```{r}
str(sig_deg)
```


### Make background

We will use the full set of genes that were returned by `DESeq2`. This set should have filtered out genes that have low counts.

We can use the same function from earlier to convert our list of _Pelobates_ IDs to _Xenopus_ peptide IDs.

```{r}
# function to pull out xtr background IDs
extract_xtr<-function(x) {
  return(
      xtrop %>%
        filter(gene_id %in% x) %>%
        pull(xenp_pep_id) %>%
        str_split(pattern=";") %>%
        unlist() %>%
        na.omit() %>%
        unique()
  )
}

xtr_bg<-lapply(res, FUN= function(x) extract_xtr(rownames(x)))
str(xtr_bg)

# lets unify the background to use the same across all populations
xtr_bg_all<-xtr_bg %>%
  unlist() %>%
  unique()

```

## Functional Enrichment Analysis

Here, we will use [g:Profiler])(https://biit.cs.ut.ee/gprofiler/), because it plays particularly well with R and with Ensembl gene/peptide annotations.  

```{r}
# set base url:
set_base_url("https://biit.cs.ut.ee/gprofiler_archive3/e109_eg56_p17/")

# run the analysis
res_ora<-gost(multi_query = FALSE, # returns separate results tables for multiquery
              custom_bg = xtr_bg_all, # our background
              query=sig_deg, # our list of gene sets
              organism="xtropicalis", # the organism our annotations belong to
              exclude_iea = FALSE, # include GO terms that were electronically assigned
              correction_method = "gSCS", # the recommended multiple testing correction.
              sources=c("GO:BP","GO:CC","GO:MF", "KEGG","REAC"), # the functional sets we are interested in 
              evcodes=FALSE, ## evcodes TRUE needed for downstream analysis like enrichment maps in Cytoscape, but this takes longer.
              significant= FALSE) # return all terms, not just the significant ones


# the results are stored as a "results" dataframe 
head(res_ora$result)
```


We can use a p_value cutoff of 0.05 to see how many terms have been functionally enriched in each term.

```{r}
res_ora$result %>%
  filter(p_value<0.05) %>%
  group_by(query) %>%
  dplyr::count(query, sort=TRUE)
```


## GOST plot

```{r fig.height=12, fig.fullwidth=TRUE}
gostplot(res_ora)
```


```{r}
scico_palette_show()
```


## Dotplot

Custom dot plot using the gprofiler results tables and ggplot.

```{r fig.height=12, fig.width=10}
res_ora$result %>%
  select(query,term_name, p_value, intersection_size, query_size,source) %>%
  filter(p_value<0.05) %>%
  mutate(GeneRatio=intersection_size/query_size) %>%
  arrange(GeneRatio) %>%
  mutate(term_name = factor(term_name, levels=unique(term_name))) %>%
  ggplot(aes(x=GeneRatio, y=term_name)) +
  geom_point(aes(color=p_value, size=intersection_size)) +
  ylab("") +
  # scale_color_scico(palette = "vikO", direction = 1) +
  facet_grid(source~query,scales = "free_y",space = "free") +
  theme_bw()
```

