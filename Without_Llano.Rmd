---
title: "Removing_Llano"
author: "clagrabel"
date: "2024-03-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


We load and store the data into a variable called txi.

```{r}
txi<-readRDS("salmon_gene_counts.rds")
```

We will load the libraries needed for this script.

```{r}
# use pacman to load libraries
pacman::p_load(tidyverse, DESeq2, pheatmap)
```


# Exploring the data

```{r, include=FALSE}
class(txi)
summary(txi)
lapply(X=txi, FUN=head)
```

The txi object is a list with 4 entries, three matrices (abundance, counts, length) and 1 character vector (countsFromAbundance).

The dimensions of each matrix are 106236 rows as the genes and 48 columns as the sample_id. This means the transcripts have been aggregated into 106236 genes.

```{r}
dim(txi$abundance)
```

Here is a brief description of each element in the txi object: 
* Counts: Estimate of the number of reads mapping to each transcript.
* Abundance: Normalized counts in Transcripts Per Million (TPM). This means that per sample, the total counts add up to 1 million. Raw counts cannot be compared across sample_id because each library may vary slightly in terms of the total number of reads, differences in sequencing bias and difference in transcript lengths. 

```{r}
apply(X=txi$abundance, FUN=sum, MARGIN = 2)
```

* Length: Effective length of the target transcript.
* countsFromAbundance: A character vector indicating whether counts were taken directly from the quantifier (salmon) or whether they have been calculated from the abundances by tximport. Default is no (counts are from salmon).


Moreover, we can appreciate that the two first rows correspond to transcripts that mapped against mithocondrial RNA and non-coding RNA (nuclear ribosomal RNA) decoys introduced in the reference transcriptome. 

We will remove these rows.

_Regarding the non-coding RNA, we can see high counts in the counts matrix (without any normalization). Non-coding RNA molecules are abundant in the cell and are often not fully removed during RNA purification processes. All the transcripts were aggregated into one only "gene" or row called nrRNA, therefore showing a higher length  in the length matrix. Longer transcripts are expected to garner more reads simply because they provide more binding sites for the sequencing reads. Thus, in the abundance matrix their abundance is adjusted downward to account for their length._


# Filtering out mtRNA and nrRNA

We have to filter out the first two rows of every matrix. These two rows correspond to the mitochondrial RNA and nuclear ribosomal RNA that mapped against the decoys introduced in the reference transcriptome.

Moreover, there are genes named with the prefix "PECUL23nc" that are also non-coding. We have to find these genes and remove them too.

```{r, include=FALSE}

txi_filtered <- lapply(txi, function(x) {
  # Check if x is a matrix or a data frame
  if (is.matrix(x) || is.data.frame(x)) {
    # Identify rows whose names contain "PECUL23nc"
    rows_to_remove <- grep("PECUL23nc", rownames(x))
    # Combine the rows to remove: the first two rows and rows with specific names
    all_rows_to_remove <- unique(c(1, 2, rows_to_remove))
    # Remove the specified rows
    return(x[-all_rows_to_remove, ])
  } else {
    # If not, return x unchanged
    return(x)
  }
})

# Now, each matrix in the txi list has had the first two rows removed, all the rows containing non-coding RNA removed, and the countsFromAbundance element was not changed.

lapply(X=txi_filtered, FUN=head)
dim(txi_filtered$abundance)
dim(txi_filtered$counts)
dim(txi_filtered$length)

```


# Re-formatting

Changing the names of the columns for the matrices in the txi object.

```{r, include=FALSE}

# install.packages("Hmisc")
library(Hmisc)

# Creating a vector containing the new names for the samples

samples_by_replicate <- sort(unique(Cs(Bui1H, Bui1H, Bui1L, Bui1L, Bui2H, Bui2H, Bui2L, Bui2L, Bui3H, Bui3H, Bui3L, Bui3L, Bui4H, Bui4H, Bui4L, Bui4L, Can1H, Can1H, Can1L, Can1L, Can2H, Can2H, Can2L, Can2L, Can3H, Can3H, Can3L, Can3L, Can4H, Can4H, Can4L, Can4L, Esp1H, Esp1H, Esp1L, Esp1L, Esp2H, Esp2H, Esp2L, Esp2L, Esp3H, Esp3H, Esp3L, Esp3L, Esp4H, Esp4H, Esp4L, Esp4L, Jab1H, Jab1H, Jab1L, Jab1L, Jab2H, Jab2H, Jab2L, Jab2L, Jab3H, Jab3H, Jab3L, Jab3L, Jab4H, Jab4H, Jab4L, Jab4L, Lla1H, Lla1H, Lla1L, Lla1L, Lla2H, Lla2H, Lla2L, Lla2L, Lla3H, Lla3H, Lla3L, Lla3L, Lla4H, Lla4H, Lla4L, Lla4L, Tur1H, Tur1H, Tur1L, Tur1L, Tur2H, Tur2H, Tur2L, Tur2L, Tur3H, Tur3H, Tur3L, Tur3L, Tur4H, Tur4H, Tur4L, Tur4L)))


# Converting the vector's elements into characters using Cs from the package Hmisc, which embeds the terms in quotation marks, selecting only unique names and sorting alphabetically.


# Checking the resulting names variable
samples_by_replicate
class(samples_by_replicate)
length(samples_by_replicate)

# If the length of the names vector equals the number of columns of the matrices, then:

if(length(samples_by_replicate) == ncol(txi_filtered$counts)) {
  # Replace column names for counts, abundance, and length matrix
  colnames(txi_filtered$counts) <- samples_by_replicate
  colnames(txi_filtered$abundance) <- samples_by_replicate
  colnames(txi_filtered$length) <- samples_by_replicate
} else {
  stop("The length of the samples vector does not match the number of sample_id in the txi object.")
}

#class(txi_filtered)

```

We will group all the replicates for a specific condition together, grouping all replicates for high water level and all replicates for low water in the same population.

```{r}

sample_id<-Cs(Bui1H, Bui2H, Bui3H, Bui4H, Bui1L, Bui2L, Bui3L, Bui4L, Can1H, Can2H, Can3H, Can4H, Can1L, Can2L, Can3L, Can4L, Tur1H, Tur2H, Tur3H, Tur4H, Tur1L, Tur2L, Tur3L, Tur4L, Esp1H, Esp2H, Esp3H, Esp4H, Esp1L, Esp2L, Esp3L, Esp4L, Jab1H, Jab2H, Jab3H, Jab4H, Jab1L, Jab2L, Jab3L, Jab4L, Lla1H, Lla2H, Lla3H, Lla4H, Lla1L, Lla2L, Lla3L, Lla4L)

length(sample_id)


if(length(sample_id) == ncol(txi_filtered$counts)) {
  # Reorder the columns for counts, abundance, and length matrices within the list
  txi_filtered$counts <- txi_filtered$counts[, sample_id, drop = FALSE]
  txi_filtered$abundance <- txi_filtered$abundance[, sample_id, drop = FALSE]
  txi_filtered$length <- txi_filtered$length[, sample_id, drop = FALSE]
} else {
  stop("The length of the sample_id vector does not match the number of columns in the txi_filtered$counts matrix.")
}


#class(txi_filtered)
#lapply(X=txi_filtered, FUN=head)

```



We will remove Llano population.


```{r}
lapply(X=txi_filtered, FUN=head)

txi_test <- lapply(txi_filtered, function(x) {
  # Check if x is a matrix or a data frame
  if (is.matrix(x) || is.data.frame(x)) {
    # We want to remove columns that belong to Llano population.
    cols_to_remove <- grep("Lla", colnames(x))
    # Remove the specified rows
    return(x[, -cols_to_remove])
  } else {
    # If not, return x unchanged
    return(x)
  }
})

dim(txi_test$counts)

# Creating the experimental design

exp_design<-read.csv(file= "exp_design.csv", header=T, sep=",")
llano_rows<-grep("Llano", exp_design$populations)
llano_rows

exp_test <- exp_design %>%
              filter(!row_number() %in% llano_rows)
exp_test
```
Running DESeq2.

```{r}
dds_test <- DESeqDataSetFromTximport(
  txi = txi_test, 
  colData = exp_test,
  design = ~ waterLevel * region)
```

