---
title: "DESeq2_populations"
author: "clagrabel"
date: "2024-03-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading the necessary libraries.

```{r}
pacman::p_load(tidyverse, DESeq2)
```

# DOUBT

I could not get the interaction terms for all populations because it takes one of the populations as the baseline.

Also, I was unable to get the interaction term between population and region. I thought this would provide me with information about the uniformity between populations in the same region.

## Interaction term between Population and Water Level

From here, we can also get the effect of Population independently.

```{r}
dds_water_pop <- DESeqDataSetFromTximport(
  txi = txi_filtered, 
  colData = exp_design,
  design = ~ waterLevel * populations)

dds_water_pop <- dds_water_pop[rowSums(counts(dds_water_pop)) >= 10,]
dds_water_pop <- DESeq(dds_water_pop)
resultsNames(dds_water_pop)

```

This DESeq analysis is taking high water level and Buitrago as its references for each factor.

With the following results, we are specifically examining the effect on gene expression when the water level is "low" (compared to the reference level "high"), and the population is whichever specified in the name of the contrast (compared to the reference population).

This means, that the DEGs obtained or the change in gene expression are due to the combination of being in "low" water level conditions when in the specified population; and his change is specifically measured relative to the baseline scenario where the water level is "high" and the population is Buitrago.

```{r eval=FALSE, include=FALSE}

# Storing the interaction terms between each population and the water level

int_water_Can<-results(dds_water_pop, name ="waterLevellow.populationsCanencia")
summary(int_water_Can, alpha=0.05)

# LFC > 0 (up)       : 17, 0.088%
# LFC < 0 (down)     : 3, 0.016%

int_water_Tur<-results(dds_water_pop, name ="waterLevellow.populationsTurrubuelo")
summary(int_water_Tur, alpha=0.05)

# LFC > 0 (up)       : 8, 0.041%
# LFC < 0 (down)     : 0, 0%

# I cannot get Bui because it took it as the reference, I would have to change the reference population
#int_water_Bui<-results(dds_water_pop, name="waterLevellow.populationsBuitrago")

int_water_Esp<-results(dds_water_pop, name ="waterLevellow.populationsEspajosas")
summary(int_water_Esp, alpha=0.05)

# LFC > 0 (up)       : 3, 0.016%
# LFC < 0 (down)     : 2, 0.01%

int_water_Lla<-results(dds_water_pop, name ="waterLevellow.populationsLlano")
summary(res_water_Lla, alpha=0.05)

# LFC > 0 (up)       : 9, 0.047%
# LFC < 0 (down)     : 8, 0.041%

int_water_Jab<-results(dds_water_pop, name ="waterLevellow.populationsJabata")
summary(int_water_Jab, alpha=0.05)

# LFC > 0 (up)       : 6, 0.031%
# LFC < 0 (down)     : 5, 0.026%

```

```{r}
res_water_design_both<-results(dds_water_pop, name ="waterLevel_low_vs_high")
summary(res_water_design_both, alpha=0.05)
```

# Proof of Concept

### Only Southern Region

Only using the populations belonging only to the the southern region and performing DESeq2 on this data.


```{r}

txi_south <- lapply(txi_filtered, function(x) {
  # Check if x is a matrix or a data frame
  if (is.matrix(x) || is.data.frame(x)) {
    # We want to maintain columns that belong to the central region, so we will remove those from the southern region.
    patterns <- c("Can", "Tur", "Bui")
    pattern <- paste(patterns, collapse = "|")
    cols_to_remove <- grep(pattern, colnames(x))
    # Remove the specified rows
    return(x[, -cols_to_remove])
  } else {
    # If not, return x unchanged
    return(x)
  }
})


dim(txi_south$counts)

# If we visualize the new txi object, the desired samples have been removed correctly.

```

We will follow 3 approaches, using different designs for performing DESeq2.

  * ~ populations * waterlevel
  
In order to see the difference with the previous tests that had both regions.

This design would provide the independent main effect of waterlevel and population on gene expression, where each  factor's influence on gene expression is evaluated separately. The design also provides the interaction between them. 

The water level effect would be the effect of changing water levels while holding the population constant. 
Similarly, the coefficients for population show the effect of different populations at a fixed water level.
As for the interaction term, it would inform about whether the impact of changing water levels on gene expression differs across different populations.


The results will show genes that are differentially expressed due to:

Each population compared to a reference population (assuming other conditions like water level are held constant).
Each water level compared to a reference water level (assuming populations are held constant).
Specific combinations of population and water level, indicating interaction effectsâ€”where the expression change due to water level differs significantly among populations.


_Regarding the Statistics behind DESeq2_

DESeq2 treats both waterlevel and population as independent factors affecting gene expression. It will estimate separate effects (log2 fold changes) for each level of waterlevel and population, compared to their respective reference levels. *This is done while controlling for the other variable, meaning it assesses the impact of one factor while holding the other constant.*

Our water level treatment has levels Low and High, and let's say population has levels A and B. If Low and A are reference levels, the model estimates effects of High versus Low (holding population constant) and B versus A (holding water level constant).


```{r}

group_populations<-factor(paste0(exp_design$waterLevel, exp_design$populations))
exp_south <- cbind(exp_design, group = group_populations)
exp_south <- exp_south[region=="Southern_Spain", ]

dds_water_pop_south <- DESeqDataSetFromTximport(
  txi = txi_south, 
  colData = exp_south,
  design = ~ waterLevel * populations)

dds_water_pop_south <- dds_water_pop_south[rowSums(counts(dds_water_pop_south)) >= 10,]
dds_water_pop_south <- DESeq(dds_water_pop_south)
resultsNames(dds_water_pop_south)

```

Storing the results.

```{r eval=FALSE, include=FALSE}

# Storing the interaction terms between each population and the water level

int_south_water_Jab<-results(dds_water_pop_south, name ="waterLevellow.populationsJabata")
summary(int_south_water_Jab, alpha=0.05)

# LFC > 0 (up)       : 1
# LFC < 0 (down)     : 2

int_south_water_Llano<-results(dds_water_pop_south, name ="waterLevellow.populationsLlano")
summary(int_water_Tur, alpha=0.05)

# LFC > 0 (up)       : 8, 0.041%
# LFC < 0 (down)     : 0, 0%

# I cannot get Bui because it took it as the reference, I would have to change the reference population
#int_south_water_Bui<-results(dds_water_pop_south, name="waterLevellow.populationsBuitrago")

```


 + ~ populations
  
Since we already filtered by the populations belonging to the southern region, checking only for the populations effect.

DESeq2 models gene expression differences based solely on population differences. It estimates the effects of each population level compared to a reference population, without considering any other factors like water level.

If populations are A and B, with A as the reference, the model estimates the effect of B versus A. The model does not merge the water levels or select any single level as a baseline; it simply excludes water level from the model altogether.

All variation in gene expression is analyzed as if it stems only from differences among populations. The analysis proceeds with the assumption that either water level does not impact gene expression, or that its impact is uniformly distributed across all populations.

If water level actually affects gene expression and this effect varies between populations, excluding water level from the model could lead to confounded results. 

_Confounding in statistics refers to a situation where the effect of a primary independent variable (the factor of interest) on an outcome is mixed up with the effect of a third variable, known as the confounder. The confounder is a variable that influences both the independent variable and the dependent variable, leading to a potential distortion in the estimated relationship between the independent variable and the dependent variable._



```{r}

dds_pop_south <- DESeqDataSetFromTximport(
  txi = txi_south, 
  colData = exp_south,
  design = ~ populations)

dds_pop_south <- dds_pop_south[rowSums(counts(dds_pop_south)) >= 10,]
dds_pop_south <- DESeq(dds_pop_south)
resultsNames(dds_pop_south)

```

Storing the results in variables

```{r}

```


  + ~ waterLevel

Since we already filtered by the populations belonging to the southern region, checking only for the waterLevel effect.

This design assesses the direct impact of water level changes on gene expression across the southern populations. This can be  useful for understanding environmental stress responses or adaptations.


  + ~ group
  
Being the group factor a combination of the water level and populations factors in a new column in the experimental design matrix.

In this design, group is a fusion of populations and waterlevel, with each unique combination treated as a distinct group. This approach is best suited for identifying differential expression patterns that are specific to unique combinations of population and water level.

The model inherently captures interactions between populations and water levels because it is directly modeling each unique combination as a distinct group. If it is suspected that the effect of water level might depend on the population (or vice versa), this is a suitable approach.

In our case, it is of interest the see the interaction between the population effect and the water effect.


Since the levels are "highEspajosas" "highJabata" "highLlano" "lowEspajosas"  "lowJabata" "lowLlano", the reference that DESeq2 takes is the first alphabetically so in this case it's high Espajosas.

This means that what DESeq does it taking each group and comparing it/making it relative to the reference, and then those groups who have been compared to the reference are compared between themselves.

```{r}

# Grouping water level and populations.

dds_south_group <- DESeqDataSetFromTximport(
  txi = txi_south, 
  colData = exp_south,
  design = ~ group)

dds_south_group <- dds_south_group[rowSums(counts(dds_south_group)) >= 10,]
dds_south_group <- DESeq(dds_south_group)

resultsNames(dds_south_group)

```

```{r}

poc_EspH_EspL <- results(dds_south_group, contrast=c("group", "lowEspajosas", "highEspajosas"))
summary(poc_EspH_EspL, alpha=0.05)

# LFC > 0 (up)       : 6, 0.033%
# LFC < 0 (down)     : 8, 0.044%
# outliers [1]       : 394, 2.2%
# low counts [2]     : 2445, 13%

poc_JabH_JabL <- results(dds_south_group, contrast=c("group", "lowJabata", "highJabata"))
summary(poc_JabH_JabL, alpha=0.05)

# LFC > 0 (up)       : 82, 0.45%
# LFC < 0 (down)     : 62, 0.34%
# outliers [1]       : 394, 2.2%
# low counts [2]     : 4395, 24%

poc_LlaH_LlaL <- results(dds_south_group, contrast=c("group", "lowLlano", "highLlano"))
summary(poc_LlaH_LlaL, alpha=0.05)

# LFC > 0 (up)       : 82, 0.45%
# LFC < 0 (down)     : 62, 0.34%
# outliers [1]       : 394, 2.2%
# low counts [2]     : 4395, 24%

```


### Each population separately






```{r eval=FALSE, include=FALSE}

# Trying to get the interaction term between population and region 

txi_central <- lapply(txi_filtered, function(x) {
  # Check if x is a matrix or a data frame
  if (is.matrix(x) || is.data.frame(x)) {
    # We want to maintain columns that belong to the central region, so we will remove those from the southern region.
    patterns <- c("Lla", "Esp", "Jab")
    pattern <- paste(patterns, collapse = "|")
    cols_to_remove <- grep(pattern, colnames(x))
    # Remove the specified rows
    return(x[, -cols_to_remove])
  } else {
    # If not, return x unchanged
    return(x)
  }
})

dim(txi_central$counts)

#table(exp_central$populations)
#length(exp_central$populations)

exp_central <- exp_design[region=="Central_Spain", ]
exp_central

dds_central_pop <- DESeqDataSetFromTximport(
  txi = txi_central, 
  colData = exp_central,
  design = ~ populations)

dds_central_pop <- dds_central_pop[rowSums(counts(dds_central_pop)) >= 10,]
dds_central_pop <- DESeq(dds_central_pop)
resultsNames(dds_central_pop)
```
