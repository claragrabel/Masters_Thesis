---
title: "DESeq2 on Populations"
author: "H. Christoph Liedtke"
date: "2024-05-21"
output:
  html_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

In this document, we will analyse RNAseq data (counts at gene level from salmon) using DESeq2. The data comes from 6 populations (of 2 geographic regions) and each population was subjected to benign conditions (constant high water level) and stressful conditions (low water level).

## Prep environment

Set working directory and load libraries

```{r}
#setwd("~/Desktop/rnaseq/")
setwd("~/Documents/students_MSc/clara/rnaseq/")

library(DESeq2)
library(tidyverse)
library(fdrtool)
library(UpSetR)
library(GGally)
library(fdrtool)
```

## Import read counts

Import counts prepared with tximport and clean

```{r}
txi<-readRDS("./salmon_gene_counts.rds")

```


Remove non-coding regions and baits

```{r}

# remove mtDNA, non-coding and nr baits

# make a list of genes we want to keep
whitelist<-txi$counts %>%
  as_tibble(rownames = "gene_id") %>%
  filter(!str_detect(gene_id, pattern = "mt|nr|nc")) %>%
  pull(gene_id)

length(whitelist);head(whitelist) # we are keeping 32531 genes

# filter txi tables
txi$abundance<-txi$abundance[whitelist,]
txi$counts<-txi$counts[whitelist,]
txi$length<-txi$length[whitelist,]
```


## Load design matrix

Load the "column data" for the dds object. Because in this script we will analyse each population separately, I will also make population-specific txi-objects. Because we will do much of the steps 6 times (once for each population), we will heavily rely on `lapply()` and `for()` loops.

```{r}
### load design matrix
des.mat<-read_csv("./design_matrix.csv")

# re order factor levels
des.mat <- des.mat %>%
  mutate(population=factor(population, levels=c("Bui","Can","Tur","Esp","Jab","Lla"))) %>% # re-order factors for easy plotting later
  mutate(pop_n = factor(rep(rep(1:3,each=8),2))) %>% # make new, non-nested pop variable !!! BECAREFUL WITH THE ORDER OF VARIABLES
  mutate_if(is.character, as.factor) # convert characters to factor


# filter samples that had substantially lower library size (Jab) and a potential outlier (Bui)
des.mat<-des.mat %>%
  filter(!sample_id %in% c("Bui4H14_nonrrna","Jab5H6_nonrrna")) # could also remove: "Tur2H6_nonrrna","Bui1L9_nonrrna"

# filter txi tables
txi$abundance<-txi$abundance[,as.character(des.mat$sample_id)]
txi$counts<-txi$counts[,as.character(des.mat$sample_id)]
txi$length<-txi$length[,as.character(des.mat$sample_id)]

## get column order of counts matrix and re-order des.mat to match
col_order<-match(colnames(txi$counts),des.mat$sample_id)
des.mat<-des.mat[col_order,]
des.mat$sample_id==colnames(txi$counts)

des.mat


### make population subsets (there is probably a better way to do this)
unique(des.mat$population)

txi_bui<-txi
txi_can<-txi
txi_tur<-txi
txi_esp<-txi
txi_jab<-txi
txi_lla<-txi


txi_bui$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Bui"])]
txi_bui$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Bui"])]
txi_bui$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Bui"])]

txi_can$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Can"])]
txi_can$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Can"])]
txi_can$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Can"])]

txi_tur$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Tur"])]
txi_tur$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Tur"])]
txi_tur$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Tur"])]

txi_esp$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Esp"])]
txi_esp$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Esp"])]
txi_esp$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Esp"])]

txi_jab$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Jab"])]
txi_jab$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Jab"])]
txi_jab$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Jab"])]

txi_lla$abundance<-txi$abundance[whitelist,as.character(des.mat$sample_id[des.mat$population=="Lla"])]
txi_lla$counts<-txi$counts[whitelist,as.character(des.mat$sample_id[des.mat$population=="Lla"])]
txi_lla$length<-txi$length[whitelist,as.character(des.mat$sample_id[des.mat$population=="Lla"])]
```


## Make DESeq objects


Make deseq object for each population and then store them in a list. Deseq objects will test only the effects of treatment (low vs.high water).


```{r}
dds_bui<-DESeqDataSetFromTximport(txi_bui,
                                  colData = des.mat %>%
                                    filter(population=="Bui"),
                                  design = ~ treatment)
dds_bui


dds_can<-DESeqDataSetFromTximport(txi_can,
                                  colData = des.mat %>%
                                    filter(population=="Can"),
                                  design = ~ treatment)
dds_can

dds_tur<-DESeqDataSetFromTximport(txi_tur,
                                  colData = des.mat %>%
                                    filter(population=="Tur"),
                                  design = ~ treatment)
dds_tur


dds_esp<-DESeqDataSetFromTximport(txi_esp,
                                  colData = des.mat %>%
                                    filter(population=="Esp"),
                                  design = ~ treatment)
dds_esp


dds_jab<-DESeqDataSetFromTximport(txi_jab,
                                  colData = des.mat %>%
                                    filter(population=="Jab"),
                                  design = ~ treatment)
dds_jab


dds_lla<-DESeqDataSetFromTximport(txi_lla,
                                  colData = des.mat %>%
                                    filter(population=="Lla"),
                                  design = ~ treatment)
dds_lla

## combine into list

dds<-list("bui"=dds_bui,
          "can"=dds_can,
          "tur"=dds_tur,
          "esp"=dds_esp,
          "jab"=dds_jab,
          "lla"=dds_lla)
```


## Pre filtering

This is an ambiguous step. It may be worth playing around with how this affects the final outcome.

```{r}
# no. of genes before pre-filtering
lapply(dds, dim)


# filtering
dds<-lapply(dds, FUN=function(x){
  x[rowSums(counts(x) >= 10) >= 4,] ## keep only rows that have at least 10 count for 4 sample
}  )

# no. of genes after pre-filtering
lapply(dds, dim)
```


## Data exploration

Its always a good idea to plot a PCA of the counts data.  
 
 
Although for the actual DE expression we use raw count data, for visualization or clustering, it makes more sense to use some sort of transformed count. DESeq authors argue that variance stabilized transformation (VST) or regularized logarithm (rlog) have certain advantages. VST is faster, i.e. good for large datasets, rlog is more often used for small datasts. lets do rlog here.

```{r}
# rlog transformation
rlog_pops<-lapply(dds, rlog, blind=T)

# perform PCA on TRANSPOSED scaled, centered data
pca_pops<- lapply(rlog_pops, function(x){
  prcomp(t(assay(x)), center=T)
})
```

To plot multiple axes at once, I am going to use paired plots. The densitites on the diagonal are also useful for seeing which PC does the best job at separating out treatments. Lets look at each population individually and up to 4 PCA components

### Bui
```{r}
# check rownames match
colnames(assay(dds_bui))==dds_bui$sample_id

pca_pops$bui$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment)) +
  ggtitle("Bui")

```

PC3 is definitely doing the best job at separating out the treatments.

### Can
```{r}
# check rownames match
colnames(assay(dds_can))==dds_can$sample_id

pca_pops$can$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment))+
  ggtitle("Can")
```

No clear treatment separation. Perhaps when plotting PC2 and PC4. 

### Tur
```{r}
# check rownames match
colnames(assay(dds_tur))==dds_tur$sample_id

pca_pops$tur$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment))+
  ggtitle("Tur")
```

Same as for Can. Some separation with PC3 and PC4.


### Esp
```{r}
# check rownames match
colnames(assay(dds_esp))==dds_esp$sample_id

pca_pops$esp$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment))+
  ggtitle("Esp")
```

Very little separation

### Jab
```{r}
# check rownames match
colnames(assay(dds_jab))==dds_jab$sample_id

pca_pops$jab$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment))+
  ggtitle("Jab")
```

Potential outliers as detected by PC1. Otherwise good separation with PC2.

### Lla
```{r}
# check rownames match
colnames(assay(dds_lla))==dds_lla$sample_id

pca_pops$lla$x %>%
  as_tibble(rownames = "sample_id") %>%
  left_join(des.mat) %>% # add the experimental design information
  ggpairs(columns = c("PC1", "PC2", "PC3", "PC4"), aes(color=treatment)) +
  ggtitle("Lla")
```

Best separation when plotting PC1 vs PC2, but large variance

## Differential gene expression

we can now run the DESeq pipeline, which will automatically run a number of steps including controlling for different library sizes etc, and finally also fitting the generalized linear model. 


```{r}
dds<-lapply(dds,DESeq)
```

Run the standards Wald's test to compare treatments

```{r}
res_dds<-lapply(dds, results, name= "treatment_L_vs_H")
lapply(res_dds, summary, alpha=0.05)
```

In general, quite low numbers of DEGs except for LLano. We should definitely inspect the p-value distributions

```{r}
par(mfrow=c(3,2))
for(i in 1:length(res_dds)){
  hist(res_dds[[i]]$pvalue, breaks=20, col="grey", main=names(res_dds)[i])
}
par(mfrow=c(1,1))
```

The madrid populations don't look that great

## Local dispersion fits

in general, p values should be evenly distributed, with an inflation of p=0. Common "bad" distributions include "U-shaped" distributions or "hill shaped" distributions. The present distribution is not bad, but we can see if it would be better using a local fit instead of a parametric fit for the dispersion.

```{r}
dds_loc<-lapply(dds, FUN = DESeq, fitType = "local")
resultsNames(dds_loc[[1]])

# compares Low vs High (high is the reference level for treatment) in the central region
res_dds_loc<-lapply(dds_loc, results, name= "treatment_L_vs_H")
lapply(res_dds_loc, summary, alpha=0.05)

# new p-values
par(mfrow=c(3,2))
for(i in 1:length(res_dds_loc)){
  hist(res_dds_loc[[i]]$pvalue, breaks=20, col="grey", main=names(res_dds_loc)[i])
}
par(mfrow=c(1,1))
```

Looks a little better.

## Visualize DEGS

```{r}

# plot new p-values
res_dds_loc %>%
  lapply(as_tibble,rownames = "gene_id") %>%
  bind_rows(.id="population") %>%
  mutate(population=factor(population, levels=c("bui","can","tur","esp","jab","lla"))) %>%
  drop_na(padj) %>% # drop all genes with NAs
  filter(padj<0.05) %>%
  mutate(updown=ifelse(log2FoldChange>0, "up", "down")) %>%
  group_by(population, updown) %>%
  summarise(n=n()) %>%
  mutate(DEGs=ifelse(updown=="down", n*-1, n)) %>%
  ggplot(aes(x=population, y=DEGs, fill=updown)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Number of DEGs per population")

```

Looking at the size of the response alone, Llano is a clear outlier, but also the southern populations are showing more DEGs than the madrid populations.

## Compare overlap

Rather than just the numbers of genes, we also want to see how many shared sets of genes the different populations have in their sets of DEGs.

```{r}
# make function to extract lists of DEGs per population
extract_degs<-function(x) {
  return(
    x %>%
      as_tibble(rownames = "gene") %>%
      filter(padj<0.05) %>%
      pull(gene)
  )
}

#  extract all
sig_deg<-lapply(res_dds_loc, FUN=extract_degs)
str(sig_deg)


# Plot Upset

upset(fromList(sig_deg),
      nsets = length(sig_deg),
      sets=c("bui","can", "tur","esp","jab","lla"),
      keep.order = T,
      nintersects = 100,
      number.angles = 0, point.size = 3, line.size = 1,
      sets.x.label = "Number of DEGs",
      set_size.show = TRUE,
      set_size.scale_max = max(sapply(sig_deg, length))+50, # needed only to expand the axis a bit
      text.scale = c(1.2, 1.2, 1.2, 1.2, 1.5, 1.5),
      sets.bar.color = rep(c("skyblue","chartreuse3"), each=3),
      order.by=c("degree","freq"))

```

Most DEGs are unique to populations. There are only few overlapping genes and they are not immediately clustering into regions.


## Export data

```{r}
# make a results folder if it does not yet exist
dir.create("results", showWarnings = FALSE)

# save DESeq2 object
saveRDS(dds_loc, "./results/deseq2_dds.rds")

# save results object
saveRDS(res_dds_loc,
        "./results/deseq2_results.rds")

```

